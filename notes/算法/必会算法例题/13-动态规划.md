## 0. 讲解视频

[理论讲解-1](https://www.bilibili.com/video/av46292575/?p=44)

[理论讲解-2](https://www.bilibili.com/video/av46292575/?p=45)

[习题讲解-1](https://www.bilibili.com/video/av46292575/?p=46)

[习题讲解-2](https://www.bilibili.com/video/av46292575/?p=47)

[习题讲解-3](https://www.bilibili.com/video/av46292575/?p=48)

[习题讲解-4](https://www.bilibili.com/video/av46292575/?p=49)

[习题讲解-5](https://www.bilibili.com/video/av46292575/?p=50)

[习题讲解-6](https://www.bilibili.com/video/av46292575/?p=51)

[习题讲解-7](https://www.bilibili.com/video/av46292575/?p=52)

## 1. 爬台阶

[Leetcode - 70 Climbing Stairs (Easy)](https://leetcode.com/problems/climbing-stairs/)

题目描述：每次能爬一个或两个台阶，如果有 n 个台阶的话，计算爬到顶端的方法数量。

解题思路：dp(1) = 1   dp(2) = 2  dp(n) = dp(n - 1) + dp(n - 2)

```java
public int climbStairs(int n) {
    if(n <= 0) return 0;
    if(n <= 2) return n;
    int f1 = 1, f2 = 2;
    for(int i = 3; i <= n; i++){
        int t = f1 + f2;
        f1 = f2;
        f2 = t;
    }
    return f2;
}
```

## 2. 三角形

[Leetcode - 120 Triangle (Medium)](https://leetcode.com/problems/triangle/)

题目描述：给定一个三角形，寻找一条自上而下的路径，使得路径和最短，只能向下走相邻的节点。

解题思路： 每个节点记录从下到上的最短路径和。

dp[i] = min(triangle[j], triangle[j + 1]) + triangle[i][j]

```java
public int minimumTotal(List<List<Integer>> triangle) {
    int[] res = new int[triangle.size() + 1];
    for (int i = triangle.size() - 1; i >= 0; i--) {
        for (int j = 0; j < triangle.get(i).size(); j++) {
            res[j] = Math.min(res[j], res[j + 1]) + triangle.get(i).get(j);
        }
    }
    return res[0];
}
```

## 3. 最大乘积子序列

[Leetcode - 152 Maximum Product Subarray (Medium)](https://leetcode.com/problems/maximum-product-subarray/)

```
Input: [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.
```

解题思路：记录从 0 到 i，每个 i 的最大乘积值与最小乘积值。

```java
public int maxProduct(int[] nums) {
    if(nums.length == 0) return 0;
    int maxPre = nums[0];
    int minPre = nums[0];
    int max, min;
    int maxSoFar = nums[0];
    for(int i = 1; i < nums.length; i++){
        max = Math.max(Math.max(maxPre * nums[i], minPre * nums[i]), nums[i]);
        min = Math.min(Math.min(maxPre * nums[i], minPre * nums[i]), nums[i]);
        System.out.println(max + " " + min);
        maxSoFar = Math.max(max, maxSoFar);
        maxPre = max;
        minPre = min;
    }
    return maxSoFar;
}
```

## 4. 股票买卖系列

### 最佳买卖股票的时间 I

[Leetcode - 121 Best Time to Buy and Sell Stock (Easy)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)

题目描述：最多交易一次。

#### DP 解法

```java
public int maxProfit(int[] prices) {
    if(prices == null || prices.length == 0) return 0;
    int[][] mp = new int[prices.length][3];
    mp[0][1] = -prices[0];
    int res = 0;
    for (int i = 1; i < prices.length; i++){
        mp[i][0] = mp[i - 1][0]; // 没有买卖
        mp[i][1] = Math.max(mp[i - 1][1], mp[i - 1][0] - prices[i]); // 买了股票
        mp[i][2] = mp[i - 1][1] + prices[i]; // 卖了股票
        res = Math.max(res, Math.max(mp[i][0], Math.max(mp[i][1], mp[i][2])));
    }
    return res;
}
```

#### 优解

```java
public int maxProfit(int prices[]) {
    int minprice = Integer.MAX_VALUE;
    int maxprofit = 0;
    for (int i = 0; i < prices.length; i++) {
        if (prices[i] < minprice)
            minprice = prices[i];
        else if (prices[i] - minprice > maxprofit)
            maxprofit = prices[i] - minprice;
    }
    return maxprofit;
}
```

### 最佳买卖股票的时间 II

[Leetcode - 122 Best Time to Buy and Sell Stock II (Easy)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)

题目描述：能交易多次。

```java
public int maxProfit(int[] prices) {
    int profit = 0;
    for(int i = 1; i < prices.length; i++){
        if(prices[i] > prices[i - 1]){
            profit += prices[i] - prices[i - 1];
        }
    }
    return profit;
}
```

### 最佳买卖股票的时间 III

[Leetcode - 123 Best Time to Buy and Sell Stock III (Hard)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/)

题目描述：最多交易两次。
