## 0. 讲解视频

[理论讲解-1](https://www.bilibili.com/video/av46292575/?p=44)

[理论讲解-2](https://www.bilibili.com/video/av46292575/?p=45)

[习题讲解-1](https://www.bilibili.com/video/av46292575/?p=46)

[习题讲解-2](https://www.bilibili.com/video/av46292575/?p=47)

[习题讲解-3](https://www.bilibili.com/video/av46292575/?p=48)

[习题讲解-4](https://www.bilibili.com/video/av46292575/?p=49)

[习题讲解-5](https://www.bilibili.com/video/av46292575/?p=50)

[习题讲解-6](https://www.bilibili.com/video/av46292575/?p=51)

[习题讲解-7](https://www.bilibili.com/video/av46292575/?p=52)

## 1. 爬台阶

[Leetcode - 70 Climbing Stairs (Easy)](https://leetcode.com/problems/climbing-stairs/)

题目描述：每次能爬一个或两个台阶，如果有 n 个台阶的话，计算爬到顶端的方法数量。

解题思路：dp(1) = 1   dp(2) = 2  dp(n) = dp(n - 1) + dp(n - 2)

```java
public int climbStairs(int n) {
    if(n <= 0) return 0;
    if(n <= 2) return n;
    int f1 = 1, f2 = 2;
    for(int i = 3; i <= n; i++){
        int t = f1 + f2;
        f1 = f2;
        f2 = t;
    }
    return f2;
}
```

## 2. 三角形

[Leetcode - 120 Triangle (Medium)](https://leetcode.com/problems/triangle/)

题目描述：给定一个三角形，寻找一条自上而下的路径，使得路径和最短，只能向下走相邻的节点。

解题思路： 每个节点记录从下到上的最短路径和。

dp[i] = min(triangle[j], triangle[j + 1]) + triangle[i][j]

```java
public int minimumTotal(List<List<Integer>> triangle) {
    int[] res = new int[triangle.size() + 1];
    for (int i = triangle.size() - 1; i >= 0; i--) {
        for (int j = 0; j < triangle.get(i).size(); j++) {
            res[j] = Math.min(res[j], res[j + 1]) + triangle.get(i).get(j);
        }
    }
    return res[0];
}
```

## 3. 最大乘积子序列

[Leetcode - 152 Maximum Product Subarray (Medium)](https://leetcode.com/problems/maximum-product-subarray/)

```
Input: [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.
```

解题思路：记录从 0 到 i，每个 i 的最大乘积值与最小乘积值。

```java
public int maxProduct(int[] nums) {
    if(nums.length == 0) return 0;
    int maxPre = nums[0];
    int minPre = nums[0];
    int max, min;
    int maxSoFar = nums[0];
    for(int i = 1; i < nums.length; i++){
        max = Math.max(Math.max(maxPre * nums[i], minPre * nums[i]), nums[i]);
        min = Math.min(Math.min(maxPre * nums[i], minPre * nums[i]), nums[i]);
        System.out.println(max + " " + min);
        maxSoFar = Math.max(max, maxSoFar);
        maxPre = max;
        minPre = min;
    }
    return maxSoFar;
}
```