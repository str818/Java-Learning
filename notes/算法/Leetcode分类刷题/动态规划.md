
# 斐波那契

## 斐波那契数列

[Leetcode - 509 Fibonacci Number (Easy)](https://leetcode.com/problems/fibonacci-number/)

```
F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), for N > 1.
```

```java
public int fib(int N) {
    if(N <= 1) return N;
    int f1 = 0, f2 = 1;
    for(int i = 2; i <= N; i++){
        int t = f2;
        f2 = f1 + f2;
        f1 = t;
    }
    return f2;
}
```

## 爬楼梯

[Leetcode - 70 Climbing Stairs (Easy)](https://leetcode.com/problems/climbing-stairs/)

题目描述：共有 n 个台阶，每次只能往上爬 1 个或者 2 个台阶，求爬 n 个台阶共有几种不同的爬法。

```
Input: 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps
```

解题思路：

首先想到的是暴力求解，使用递归的方法依次计算，模拟向上爬 1 步与爬 2 步的情况，使用递归方法的话就不可避免的产生重复计算，时间复杂度 O(2^n)，当 n = 44 时，Leetcode 就会提示 「Time Limit Exceeded」。

```java
public int climbStairs(int n) {
    return climb_Stairs(0, n);
}
public int climb_Stairs(int i, int n) {
    if (i > n) return 0;
    if (i == n) return 1;
    return climb_Stairs(i + 1, n) + climb_Stairs(i + 2, n);
}
```

既然有重复计算，那就使用数组记录重复的计算，这样第二次计算就可以直接读取数组中记录的结果了，时间与空间复杂度均为 O(n)。

```java
public int climbStairs(int n) {
    int memo[] = new int[n + 1];
    return climb_Stairs(0, n, memo);
}
public int climb_Stairs(int i, int n, int memo[]) {
    if (i > n) return 0;
    if (i == n) return 1;
    if (memo[i] > 0) return memo[i];
    memo[i] = climb_Stairs(i + 1, n, memo) + climb_Stairs(i + 2, n, memo);
    return memo[i];
}
```

除此之外，还可以将题目分解成子结构，使用动态规划求解。定义 dp[i] 表示爬上第 i 个台阶共有几种方法，可以得到状态方程 dp[i] = dp[i - 1] + dp[i - 2]，意为前一次爬一步与爬两步到 i 的方法和。

```java
public int climbStairs(int n) {
    if (n == 1) return 1;
    int[] dp = new int[n + 1];
    dp[1] = 1;
    dp[2] = 2;
    for (int i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```

通过前面的分析，也可以看出这是一个斐波那契数列，直接使用两个变量递推即可。

```java
public int climbStairs(int n) {
    if (n <= 2) return n;
    int f1 = 1, f2 = 2;
    for(int i = 2; i < n; i++){
        int t = f2;
        f2 = f1 + f2;
        f1 = t;
    }
    return f2;
}
```

## 解码方法

[Leetcode - 91 Decode Ways (Medium)](https://leetcode.com/problems/decode-ways/)

题目描述：给定一个字符串，字母 A - Z 可以分别解码成 1 - 26，求字符串共有几种解码方法。

```
Input: "226"
Output: 3
Explanation: It could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).
```

解题思路：要注意 0 的问题，0 在前面与在后面计算方式不同。从后向前递推能够减少对 0 情况的判断。

```java
public int numDecodings(String s) {
    int n = s.length();
    if (n == 0) return 0;
    
    int[] dp = new int[n + 1];
    dp[n]  = 1;
    dp[n - 1] = s.charAt(n - 1) != '0' ? 1 : 0;
    
    for (int i = n - 2; i >= 0; i--){
        if (s.charAt(i) == '0') continue;
        else dp[i] = (Integer.parseInt(s.substring(i, i + 2)) <= 26) ? dp[i + 1] + dp[i + 2] : dp[i + 1];
    }
        
    return dp[0];
}
```

## 2. 三角形

[Leetcode - 120 Triangle (Medium)](https://leetcode.com/problems/triangle/)

题目描述：给定一个三角形形状的集合，从上到下依次向邻接位置移动，求移动的最小路径和。

```
[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).
```

解题思路：定义状态 dp[j] 为每一层第 j 个元素的最小路径和，状态方程为 dp[j] = min(dp[j], dp[j + 1]) + triangle[i][j]，这是将二维状态压缩到一维的方程，从三角形的底部向上递推。

```java
public int minimumTotal(List<List<Integer>> triangle) {
    
    int[] dp = new int[triangle.size() + 1];
    
    for(int i = triangle.size() - 1; i >= 0; i--){
        for(int j = 0; j < triangle.get(i).size(); j++){
            dp[j] = Math.min(dp[j], dp[j + 1]) + triangle.get(i).get(j);
        }
    }
    
    return dp[0];
}
```

## 4. 拆分词句

[Leetcode - 139 Word Break (Medium)](https://leetcode.com/problems/word-break/)

题目描述：给定一个字符串 s 与字典 wordDict，判断 s 是否能拆分成 wordDict 中的子字符串。

```
Input: s = "leetcode", wordDict = ["leet", "code"]
Output: true
Explanation: Return true because "leetcode" can be segmented as "leet code".
```

解题思路：定义状态 dp[i] 为 [0, i) 是否能被拆分，双重循环遍历子串是否能够被拆分成 [0, j) 和 [j, i)。

```java
public boolean wordBreak(String s, List<String> wordDict) {
    boolean[] dp = new boolean[s.length() + 1];
    dp[0] = true;
    for(int i = 0; i <= s.length(); i++){
        for(int j = 0; j < i; j++){
            if(dp[j] && wordDict.contains(s.substring(j, i))){
                dp[i] = true;
                break;
            }
        }
    }
    return dp[s.length()];
}
```

# 矩阵路径

## 最小路径和

[Leetcode - 64 Minimum Path Sum (Medium)](https://leetcode.com/problems/minimum-path-sum/)

题目描述：给定 m × n 的矩阵，只能向下或向右移动，求从左上角到右下角路径的最小路径和。

```
Input:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
Output: 7
Explanation: Because the path 1→3→1→1→1 minimizes the sum.
```

解题思路：定义状态 dp[i][j] 为从左上角走到位置 grid[i][j] 的最小路径和。由于只计算上面和左面的方块值，所以可以压缩成一维 dp[i]，选取上方与左方的最小值。

```java
public int minPathSum(int[][] grid) {
        if (grid.length == 0 || grid[0].length == 0) {
            return 0;
        }
        int m = grid.length, n = grid[0].length;
        int[] dp = new int[n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (j == 0) {
                    dp[j] = dp[j];        // 只能从上侧走到该位置
                } else if (i == 0) {
                    dp[j] = dp[j - 1];    // 只能从左侧走到该位置
                } else {
                    dp[j] = Math.min(dp[j - 1], dp[j]);
                }
                dp[j] += grid[i][j];
            }
        }
        return dp[n - 1];
    }
```

## 不同的路径

[Leetcode - 62 Unique Paths (Medium)](https://leetcode.com/problems/unique-paths/)

题目描述：机器人只能向右或向下移动，给定矩阵的长和宽，求从左上角移动到右下角共有几种不同的路径。

<div align="center">  <img src="img/leetcode-62.png" width="50%"/> </div><br>

```
Input: m = 3, n = 2
Output: 3
Explanation:
From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -> Right -> Down
2. Right -> Down -> Right
3. Down -> Right -> Right
```

解题思路：定义状态 dp[i][j] 为走到第 i 行/第 j 列的不同路径数，dp[m - 1][n - 1] 即为所求。状态方程为 dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，每个方块的路径数等于上面与左面方块的路径数之和。由于每次只需要计算上面与左面的方块，可以将存储结构缩减到一维，使用 dp[i] 表示。第一行与第一列的方块路径数均为 1。

```java
public int uniquePaths(int m, int n) { 
    int[] dp = new int[n];
    Arrays.fill(dp, 1);
    for(int i = 1; i < m; i++){
        for(int j = 1; j < n; j++){
            dp[j] += dp[j - 1];
        }
    }
    return dp[n - 1];
}
```

除此之外，也可以使用数学公式直接求解。机器人总共移动 S = m + n - 2 次，向下移动 D = m - 1 次，问题可以转换成从 S 中取出 D 个位置的组合数量，即 C(S, D)。

```java
public int uniquePaths(int m, int n) {
    int S = m + n - 2; 
    int D = m - 1;
    long ret = 1;
    for (int i = 1; i <= D; i++) {
        ret = ret * (S - D + i) / i;
    }
    return (int) ret;
}
```

## 不同的路径 II

[Leetcode - 63 Unique Paths II (Medium)](https://leetcode.com/problems/unique-paths-ii/)

题目描述：和上一道题类似，只不过在路径中添加了障碍物，给定路径数组，1 表示障碍物，0 表示正常方块。

```
Input:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
Output: 2
Explanation:
There is one obstacle in the middle of the 3x3 grid above.
There are two ways to reach the bottom-right corner:
1. Right -> Right -> Down -> Down
2. Down -> Down -> Right -> Right
```

解题思路：和上一道题的状态方程相同，只不过增加了判断条件，当遇到障碍物时直接置 0。

```java
public int uniquePathsWithObstacles(int[][] obstacleGrid) {
    if(obstacleGrid == null || obstacleGrid.length == 0) return 0;
    
    int[] dp = new int[obstacleGrid[0].length];
    dp[0] = obstacleGrid[0][0] == 1 ? 0 : 1;
    
    for(int i = 0; i < obstacleGrid.length; i++){
        for(int j = 0; j < obstacleGrid[0].length; j++){
            if(obstacleGrid[i][j] == 1){
                dp[j] = 0;
            }else if(j > 0){
                dp[j] += dp[j - 1];
            }
        }
    }
    
    return dp[dp.length - 1];
}
```

# 数组区间

## 区间和检索

[Leetcode - 303 Range Sum Query - Immutable (Easy)](https://leetcode.com/problems/range-sum-query-immutable/)

题目描述：给定一个整型数组，计算下标 i 与 j 之间的和。

```
Given nums = [-2, 0, 3, -5, 2, -1]

sumRange(0, 2) -> 1
sumRange(2, 5) -> -1
sumRange(0, 5) -> -3
```

解题思路：定义 dp[i] 为 [0,i) 的和，这样若计算 m 到 n 的和可以转换为 dp[n] - dp[m]，避免了重复计算。

```java
private int[] sum;
public NumArray(int[] nums) {
    sum = new int[nums.length + 1];
    for(int i = 0; i < nums.length; i++){
        sum[i + 1] = sum[i] + nums[i]; 
    }
}

public int sumRange(int i, int j) {
    return sum[j + 1] - sum[i];
}
```

## 算数切片

[Leetcode - 413 Arithmetic Slices (Medium)](https://leetcode.com/problems/arithmetic-slices/)

题目描述：给定一个数组，求数组中长度在 3 个以上（包含三个）的等差数列的数量。

```
A = [1, 2, 3, 4]

return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.
```

|   数组    | 等差数列的数量 |   比较    |
| :-------: | :------------: | :-------: |
|   1 2 3   |       1        | 1 - 0 = 1 |
|  1 2 3 4  |       3        | 3 - 1 = 2 |
| 1 2 3 4 5 |       6        | 6 - 3 = 3 |

```java
public int numberOfArithmeticSlices(int[] A) {
    int[] dp = new int[A.length];
    int sum = 0;
    for(int i = 2; i < A.length; i++){
        if(A[i] - A[i - 1] == A[i - 1] - A[i - 2]){
            dp[i] = dp[i - 1] + 1;
            sum += dp[i];
        }
    }
    return sum;
}
```

# 分割整数

## 整数拆分

[Leetcode - 343 Integer Break (Medium)](https://leetcode.com/problems/integer-break/)

题目描述：给定一个整数 n，求相加等于 n 并且成绩最大的一组整数的积。

```
Input: 10
Output: 36
Explanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36.
```

解题思路：定义状态 dp[i] 为 i 对应的最大乘积。

```java
public int integerBreak(int n) {
    int[] dp = new int[n + 1];
    dp[1] = 1;
    for(int i = 2; i <= n; i++){
        for(int j = 1; j <= i - 1; j++){
            dp[i] = Math.max(dp[i], Math.max(dp[i - j] * j, (i - j) * j));
        }
    }
    return dp[n];
}
```

## 完全平方数

[Leetcode - 279 Perfect Squares (Medium)](https://leetcode.com/problems/perfect-squares/)

题目描述：给定一个正整数，求最少能由几个完全平方数组成。

```
Input: n = 13
Output: 2
Explanation: 13 = 4 + 9.
```

解题思路：定义状态 dp[n] 表示 n 的最少完全平方数，状态方程为 dp[n] = Min{ dp[n - i*i] + 1 }。

```
dp[0] = 0 
dp[1] = dp[0]+1 = 1
dp[2] = dp[1]+1 = 2
dp[3] = dp[2]+1 = 3
dp[4] = Min{ dp[4-1*1]+1, dp[4-2*2]+1 } 
      = Min{ dp[3]+1, dp[0]+1 } 
      = 1				
dp[5] = Min{ dp[5-1*1]+1, dp[5-2*2]+1 } 
      = Min{ dp[4]+1, dp[1]+1 } 
      = 2
						.
						.
						.
dp[13] = Min{ dp[13-1*1]+1, dp[13-2*2]+1, dp[13-3*3]+1 } 
       = Min{ dp[12]+1, dp[9]+1, dp[4]+1 } 
       = 2
						.
						.
						.
dp[n] = Min{ dp[n - i*i] + 1 },  n - i*i >=0 && i >= 1
```

```java
public int numSquares(int n) {
    int[] dp = new int[n + 1];
    Arrays.fill(dp, Integer.MAX_VALUE);
    dp[0] = 0;
    for(int i = 1; i <= n; i++){
        int min = Integer.MAX_VALUE;
        for(int j = 1; i - j * j >= 0; j++){
            min = Math.min(min, dp[i - j * j] + 1);
        }
        dp[i] = min;
    }
    return dp[n];
}
```

# 化简

## 打家劫舍

[Leetcode - 198 House Robber (Easy)](https://leetcode.com/problems/house-robber/)

题目描述：一个小偷沿着一条街偷窃，给定数组表示每家屋子的金额，如果偷窃连续的两间屋子就会触发警报，求在不触发警报的前提下，偷窃的最大金额。

```
Input: [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
             Total amount you can rob = 1 + 3 = 4.
```

解题思路：定义状态 dp[i] 表示从第 0 间到第 i 间屋子偷窃的最大金额，状态方程为：dp[i] = max(dp[i - 1], dp[i - 2] + num[i])，意为偷窃前 i 前的最大金额是「前 i - 1 间」与
「前 i - 2 间加上第 i 间」两者的最大值。

```java
public int rob(int[] num) {
    if(num == null || num.length == 0) return 0;
    int[] dp = new int[num.length + 1];
    dp[0] = 0;
    dp[1] = num[0];
    for(int i = 1; i < dp.length - 1; i++) {
        dp[i + 1] = Math.max(dp[i], dp[i - 1] + num[i]);
    }
    return dp[dp.length - 1];
}
```

上述代码中可以发现，计算过程中只需要两个变量即可完成计算。

```java
public int rob(int[] num) {
    if(num == null || num.length == 0) return 0;
    int prev1 = 0, prev2 = 0;
    for(int i = 0; i < num.length; i++){
        int t = prev2;
        prev2 = Math.max(prev1 + num[i], prev2);
        prev1 = t;
    }
    return prev2;
}
```

## 打家劫舍 II

[Leetcode - 213 House Robber II (Medium)](https://leetcode.com/problems/house-robber-ii/)

题目描述：一个小偷沿着一条环形的街偷窃，给定数组表示每家屋子的金额，如果偷窃连续的两间屋子就会触发警报，求在不触发警报的前提下，偷窃的最大金额。

```
Input: [2,3,2]
Output: 3
Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),
             because they are adjacent houses.
```

解题思路：此上一题是一条街，而此题是环形的街，也就是说屋子首位相接，可以借助上一题的思路，首位相接也就是只有两种情况，第一种是从第 0 到 n - 2 个屋子，另一种是从第 1 到 n - 1 个屋子，这就将环拆解成了非环。

```java
public int rob(int[] nums) {
    if(nums == null || nums.length == 0) return 0;
    if(nums.length == 1) return nums[0];
    return Math.max(robHelper(nums, 0, nums.length - 2), robHelper(nums, 1, nums.length - 1));
}

public int robHelper(int[] nums, int left, int right) {
    int prev1 = 0, prev2 = 0;
    for(int i = left; i <= right; i++) {
        int t = prev2;
        prev2 = Math.max(prev1 + nums[i], prev2);
        prev1 = t;
    }
    return prev2;
}
```

# 子序列

## 最长上升子序列

[Leetcode - 300 Longest Increasing Subsequence (Medium)](https://leetcode.com/problems/longest-increasing-subsequence/)

题目描述：给定无序的整数数组，找到最长上升子序列的长度。

```
Input: [10,9,2,5,3,7,101,18]
Output: 4 
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. 
```
解题思路：定义状态 `dp[i]` 表示从数组的头部到第 i 个元素的最长商城子序列长度。`dp[i]` 为 i 之前的最大上升子序列的长度加 1， `dp[i] = max{dp[j]} + 1`，最终的结果是所有 `dp[i]` 的最大值。在求解的过程中，需要计算第 i 个元素之前元素的最大值，可以使用二分查找的方法，将时间复杂度优化为 O(nlogn)。

```java
public int lengthOfLIS(int[] nums) {
    if(nums == null || nums.length == 0) return 0;
    int[] dp = new int[nums.length];
    dp[0] = 1;
    int maxAns = 1;
    for(int i = 1; i < dp.length; i++){
        int maxVal = 0;
        for(int j = 0; j < i; j++){
            if(nums[i] > nums[j]){
                maxVal = Math.max(maxVal, dp[j]);
            }
        }
        dp[i] = maxVal + 1;
        maxAns = Math.max(maxAns, dp[i]);
    }
    return maxAns;
}
```

## 链对的最大长度

[Leetcode - 646 Maximum Length of Pair Chain (Medium)](https://leetcode.com/problems/maximum-length-of-pair-chain/)

题目描述：对于 (a, b) 和 (c, d) ，如果 b < c，则它们可以构成一条链，求最大链的长度。

解法一：DP

```java
public int findLongestChain(int[][] pairs) {  
    int n = pairs.length;
    Arrays.sort(pairs, (a, b) -> (a[0] - b[0]));
    int[] dp = new int[n];
    Arrays.fill(dp, 1);
    for(int i = 1; i < n; i++){
        for(int j = 0; j < i; j++){
            if(pairs[i][0] > pairs[j][1]){
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
    }
    return dp[n - 1];
}
```

解法二：贪心

```java
public int findLongestChain(int[][] pairs) {
    if(pairs.length == 0) return 0;
    Arrays.sort(pairs, (a,b)->a[1]-b[1]);
    int pre = pairs[0][1];
    int count = 1;
    for(int i = 1;i<pairs.length;i++){
        if(pairs[i][0] > pre){
            count++;
            pre = pairs[i][1];
        }
    }
    return count;
}
```

## 摆动子序列

[Leetcode - 376 Wiggle Subsequence (Medium)](https://leetcode.com/problems/wiggle-subsequence/)

题目描述：一大一小就构成了摆动序列，求最长的摆动序列。

```
Input: [1,17,5,10,13,15,10,5,16,8]
Output: 7
Explanation: There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].
```

解题思路：up 与 down 分别表示当前位置是升序与降序时的子序列长度。

```java
public int wiggleMaxLength(int[] nums) {
    if(nums.length < 2) return nums.length;
    int down = 1, up = 1;
    for(int i = 1; i < nums.length; i++){
        if(nums[i] > nums[i - 1]){
            up = down + 1;
        }else if(nums[i] < nums[i - 1]){
            down = up + 1;
        }
    }
    return Math.max(down, up);
}
```