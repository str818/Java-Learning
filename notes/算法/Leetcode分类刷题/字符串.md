# 判断两字符串是否由相同字符组成

[Leetcode - 242 Valid Anagram (Easy)](https://leetcode.com/problems/valid-anagram/)

```java
public boolean isAnagram(String s, String t) {
    int[] alphabet = new int[26];
    for (int i )
    for (char c : s.toCharArray()) alphabet[c - 'a']++;
    for (char c : t.toCharArray()) alphabet[c - 'a']--;
    for (int i : alphabet) {
        if(i != 0) return false;
    }
    return true;
}
```

# 最长回文字符串

[Leetcode - 409 Longest Palindrome (Easy)](https://leetcode.com/problems/longest-palindrome/)

题目描述：求给定字符串中的字符能够组成最长字符串的长度。

```
Input:
"abccccdd"

Output:
7

Explanation:
One longest palindrome that can be built is "dccaccd", whose length is 7.
```

```java
public int longestPalindrome(String s) {
    int[] cnts = new int[256];
    for (char c : s.toCharArray()) {
        cnts[c]++;
    }
    int palindrome = 0;
    for (int cnt : cnts) {
        palindrome += (cnt / 2) * 2;
    }
    if (palindrome < s.length()) {
        palindrome++;
    }
    return palindrome;
}
```

# 同构字符串

[Leetcode - 205 Isomorphic Strings (Easy)](https://leetcode.com/problems/isomorphic-strings/)

```
Input: s = "egg", t = "add"
Output: true
Input: s = "foo", t = "bar"
Output: false
```

解题思路：判断上一次字母出现的位置是否相同。

```java
public boolean isIsomorphic(String s, String t) {
    int[] preIndexOfS = new int[256];
    int[] preIndexOfT = new int[256];
    for (int i = 0; i < s.length(); i++) {
        char sc = s.charAt(i);
        char tc = t.charAt(i);
        if (preIndexOfS[sc] != preIndexOfT[tc]) {
            return false;
        }
        preIndexOfS[sc] = i + 1;
        preIndexOfT[tc] = i + 1;
    }
    return true;
}
```

# 回文子串的数量

[Leetcode - 647 Palindromic Substrings (Medium)](https://leetcode.com/problems/palindromic-substrings/)

```
Input: "aaa"
Output: 6
Explanation: Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".
```

解题思路：依次以每个字符为中心向外扩展，计算回文子串的数量。

```java
int count = 0;
    public int countSubstrings(String s) {
        for (int i = 0; i < s.length(); i++) {
            extendPalindrome(s, i, i);
            extendPalindrome(s, i, i + 1);
        }
        return count;
    }
    public void extendPalindrome(String s, int left, int right) {
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            left--; right++; count++;
        }
    }
```

# 判断回文数

[Leetcode - 9 Palindrome Number (Easy)](https://leetcode.com/problems/palindrome-number/)

```
Input: -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.
```

```java
public boolean isPalindrome(int x) {
    if (x < 0 || (x != 0 && x % 10 == 0)) return false;
    int right = 0;
    while (x > right) {
        right = right * 10 + x % 10;
        x /= 10;
    }
    return x == right || x == right / 10;
}
```

# 计算二进制子字符串

[Leetcode - 696 Count Binary Substrings (Easy)](https://leetcode.com/problems/count-binary-substrings/)

题目描述：给定一个由 0 和 1 组成的字符串，求有多少连续分组的子串。

```
Input: "00110011"
Output: 6
Explanation: There are 6 substrings that have equal number of consecutive 1's and 0's: "0011", "01", "1100", "10", "0011", and "01".
Input: "10101"
Output: 4
Explanation: There are 4 substrings: "10", "01", "10", "01" that have equal number of consecutive 1's and 0's.
```

解题思路：统计每个分组的个数，例如 0011 的分组个数为 2 2，能够组成的连续分组子串为 01 与 0011，遍历数组利用当前分组数量与前一个分组数量计算结果。

```java
public int countBinarySubstrings(String s) {
    int prevLength = 0, curLength = 1, ans = 0;
    for (int i = 1; i < s.length(); i++) {
        if (s.charAt(i) == s.charAt(i - 1)) {
            curLength += 1;
        } else {
            prevLength = curLength;
            curLength = 1;
        }
        if (prevLength >= curLength) {
            ans += 1;
        }
    }
    return ans;
}
```

# 滑动窗口

## 找到字符串中所有字母异位词 {F}

[Leetcode - 438 Find All Anagrams in a String (Easy)](https://leetcode.com/problems/find-all-anagrams-in-a-string/)

题目描述：字母异位词是指字母相同，但排列不同的字符串。

```
Input:
s: "cbaebabacd" p: "abc"

Output:
[0, 6]

Explanation:
The substring with start index = 0 is "cba", which is an anagram of "abc".
The substring with start index = 6 is "bac", which is an anagram of "abc".
```

```java
public List<Integer> findAnagrams(String s, String p) {
    List<Integer> res = new ArrayList<>();
    if (s.length() < p.length()) return res;
    
    Map<Character, Integer> map = new HashMap<>();
    for (char c : p.toCharArray()) {
        map.put(c, map.getOrDefault(c, 0) + 1);
    }
    
    int begin = 0, end = 0;
    int counter = map.size();
    
    while (end < s.length()) {
        char c = s.charAt(end);
        if (map.containsKey(c)) {
            map.put(c, map.get(c) - 1);
            if (map.get(c) == 0) counter--;
        }
        end++;
        
        while (counter == 0) {
            char tmpc = s.charAt(begin);
            if (map.containsKey(tmpc)) {
                map.put(tmpc, map.get(tmpc) + 1);
                if(map.get(tmpc) > 0) counter++;
            }
            if (end - begin == p.length()) {
                res.add(begin);
            }
            begin++;
        }
    }
    return res;
}
```

## 最小覆盖字符串

[Leetcode - 76 Minimum Window Substring (Hard)](https://leetcode.com/problems/minimum-window-substring/)

题目描述：在字符串 S 中找出包含 T 所有字母的最小子串。

```
Input: S = "ADOBECODEBANC", T = "ABC"
Output: "BANC"
```

```java
public String minWindow(String s, String t) {
    if (s.length() < t.length()) return "";
    
    Map<Character, Integer> map = new HashMap<>();
    for (char c : t.toCharArray()) {
        map.put(c, map.getOrDefault(c, 0) + 1);
    }
    
    int counter = map.size();
    
    int begin = 0, end = 0;
    int head = 0;
    int len = Integer.MAX_VALUE;
    
    while (end < s.length()) {
        char c = s.charAt(end);
        if (map.containsKey(c)) {
            map.put(c, map.get(c) - 1);
            if (map.get(c) == 0) counter--;
        }
        end++;
        
        while (counter == 0) {
            char tmpc = s.charAt(begin);
            if (map.containsKey(tmpc)) {
                map.put(tmpc, map.get(tmpc) + 1);
                if (map.get(tmpc) > 0) {
                    counter++;
                }
            }
            if (end - begin < len) {
                len = end - begin;
                head = begin;
            }
            begin++;
        }
    }
    if (len == Integer.MAX_VALUE) return "";
    return s.substring(head, head + len);
}
```

# 无重复字符的最长子串

[Leetcode - 3 Longest Substring Without Repeating Characters (Medium)](https://leetcode.com/problems/longest-substring-without-repeating-characters/)

```
Input: "abcabcbb"
Output: 3 
Explanation: The answer is "abc", with the length of 3. 
```

解题思路：counter 记录重复字符数量。

```java
public int lengthOfLongestSubstring(String s) {
    Map<Character, Integer> map = new HashMap<>();
    int begin = 0, end = 0;
    int max = 0, counter = 0;
    while (end < s.length()) {
        char c = s.charAt(end);
        map.put(c, map.getOrDefault(c, 0) + 1);
        if (map.get(c) > 1) counter++;
        end++;
        
        while (counter > 0) {
            char tmpc = s.charAt(begin);
            if (map.get(tmpc) > 1) {
                counter--;
                map.put(tmpc, map.get(tmpc) - 1);
            }
            begin++;
        }
        max = Math.max(max, end - begin);
    }
    return max;
}
```

## 串联所有的单词

[Leetcode - 30 Substring with Concatenation of All Words (Hard)](https://leetcode.com/problems/substring-with-concatenation-of-all-words/)

题目描述：给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。

```
Input:
  s = "barfoothefoobarman",
  words = ["foo","bar"]
Output: [0,9]
Explanation: Substrings starting at index 0 and 9 are "barfoor" and "foobar" respectively.
The output order does not matter, returning [9,0] is fine too.
```

```java
public List<Integer> findSubstring(String s, String[] words) {
    List<Integer> res = new ArrayList<>();
    if (words == null || words.length == 0) return res;
    Map<String, Integer> map = new HashMap<>();
    for (String word : words) {
        map.put(word, map.getOrDefault(word, 0) + 1);
    }
    
    int len = words[0].length();
    
    for (int begin = 0; begin <= s.length() - words.length * len; begin++) {
        Map<String, Integer> seen = new HashMap<>();
        
        int end = 0;
        while (end < words.length) {
            String word = s.substring(begin + end * len, begin + (end + 1) * len);
            if (!map.containsKey(word)) break;
            seen.put(word, seen.getOrDefault(word, 0) + 1);
            if (seen.get(word) > map.get(word)) break;
            end++;
        }
        
        if (end == words.length) res.add(begin);
    }
    return res;
}
```