## 1. 验证二叉搜索树

[Leetcode - 98 Validate Binary Search Tree (Medium)](https://leetcode.com/problems/validate-binary-search-tree/)

```java
public boolean isValidBST(TreeNode root) {
    return backtrack(root, Long.MAX_VALUE, Long.MIN_VALUE);
}
public boolean backtrack(TreeNode root, long max, long min){
    if(root == null) return true;
    if(root.val >= max || root.val <= min) return false;
    return backtrack(root.left, root.val, min) && backtrack(root.right, max, root.val); 
}
```

## 2. 二叉树的最小公共祖先

[Leetcode - 236 Lowest Common Ancestor of a Binary Tree (Medium)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if(root == null || root == p || root == q) return root;
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    return left == null ? right : right == null ? left : root;
}
```

## 3. 二叉搜索树的最小公共祖先

[Leetcode - 235 Lowest Common Ancestor of a Binary Search Tree (Easy)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

解法一：遍历

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    while(root != null){
        if (p.val > root.val && q.val > root.val) {
            root = root.right;
        } else if (p.val < root.val && q.val < root.val) {
            root = root.left;
        } else {
            return root;
        }
    }
    return null;
}
```

解法二：递归

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if(root == null || root == p || root == q) return root;
    if(root.val < p.val && root.val < q.val){
        return lowestCommonAncestor(root.right, p, q);
    }else if(root.val > p.val && root.val > q.val){
        return lowestCommonAncestor(root.left, p, q);
    }
    return root;
}
```

## 4. 先序遍历

[Leetcode - 144 Binary Tree Preorder Traversal (Medium)](https://leetcode.com/problems/binary-tree-preorder-traversal/)

解法一：递归

```java
public List<Integer> preorderTraversal(TreeNode node) {
    List<Integer> res = new LinkedList<Integer>();
    preHelper(node, res);
    return res;
}
public void preHelper(TreeNode root, List<Integer> res){
    if(root == null) return;
    res.add(root.val);
    preHelper(root.left, res);
    preHelper(root.right, res);
}
```

解法二：遍历

不将左子节点放入栈中，而是直接处理。

```java
List<Integer> res = new LinkedList<Integer>();
    if(node == null) return res;
    Stack<TreeNode> stack = new Stack<>();
    stack.push(node);
    while(!stack.isEmpty()){
        TreeNode curr = stack.pop();
        res.add(curr.val);
        if(curr.right != null) stack.push(curr.right);
        if(curr.left != null) stack.push(curr.left);
    }
    return res;
}
```